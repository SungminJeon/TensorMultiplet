#block sorting algorithm
#include <iostream>
#include <fstream>
#include "Theory.h"



int main() {

	//여기서 텍스트 파일 연다. 블록은 가장 큰 {} 묶음을 지우고, 그 다음 작은 블럭을 한 행씩 배치한 녀석.
	

	//블록 하나를 행렬로 만든다. 알고리즘은 다음과 같다. 블록은  {2 2 3 1 {1 5} 1 3 2 2 1 {1 {1 12}}} 이런 형식이다. 
	
	//1. 블록을 하나 가져온다.
	//2.  4, 6,7,8, 12 중 하나의 숫자를 찾는다. 이게 바로 node다. 그 숫자를 기준으로 오른쪽에 있는  }의 개수 - {의 개수  를 센다. 이 개수를 x라고 하면 x+1이 12에 붙어있는 side link의 개수다. 
	//3. 이제 사이드 링크를 고려하자. 우선 x+1개의 matrix를 담는 녀석을 준비한다. 12의 가장 처음 오른쪽에 붙어있는 } 부터 고려한다. 이 괄호에 묶인 12를 제외한 숫자들을 모아서 -를 붙이고 대각선에 배치한다. 
	//4. 문제는 위에서 { 2 2 3 1 { 1 5 } 1 3 2 2 1 {1 { 1 12 }} 의 {1 5} 같은 녀석인데, 이 녀석은 사이드링크 2 2 3 1 { 1 5 } 1 3 2 2 1 에 해당한다. 괄호안에 있는 숫자를 제외한 녀석들이 인터섹션 넘버 1로 연결되게 배치한다.
	//5. 그리고 나서 괄호 안에 있는 녀석들이 인터섹션 넘버 1이 되게 한다. 그런 뒤에 괄호 끝쪽에 있는 숫자와 괄호 바로 밖의 숫자들이 인터섹션 넘버 1로 연결되게끔 한다.
	//6. 이렇게 사이드 링크들을 분류하고 나면, 사이드 링크들의 길이가 큰 순서대로 나열한 뒤에 블록 matrix를 합친다. 그리고 맨 뒤에 node를 붙이고, 각 블록들의 오른쪽 끝과 12의 인터섹션 넘버가 1이 되게 하여 전체 intersection form을 완성한다. 
	
	//예시
	
	대충 블록을 읽는 코드,

	if ( node넘버를 찾음. 노드 넘버의 위치를 r이라고 하자. )
	{
		node = 12; 
		node pos = r;
	}
	for ( int i= r; r < 블록크기; r++)
	{
		if ( string(r) == '}' )
		{
			num++;
		}
		else if ( string(r) == '{' )
		{
			num2++;
		}

		sidelinknum= num - num2+1;
	}
	
	여기서 sidelinknum 만큼의 matrix container를 만든다. 그리고 위의 알고리즘대로.. 
		

